<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Slog: Slog: A C++ Logging Library for Robotic Systems</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Slog
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Stream-oriented logging</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Slog: A C++ Logging Library for Robotic Systems </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__home_mike_git_slog_README"></a></p>
<ul>
<li><a href="https://github.com/mikegratton/slog">GitHub Repository</a></li>
<li><a href="https://mikegratton.github.io/slog/">Documentation</a></li>
</ul>
<p>Slog is an asynchronous stream-based logger with a memory pool. It is designed for applications where the business logic cannot wait for disk or network IO to complete recording a log record before continuing. For many server and robotic programs, log traffic comes in bursts as sessions open, plans are formed, and so on. Slog queues up messages during the busy times and catches up on IO during the lulls. For critical applications, Slog can guarantee it will not allocate memory beyond its initial pool. For "normal" applications, Slog will allocate more memory if you are logging faster than it can keep up.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Features:</h1>
<ul>
<li>Slog is configurable, but with sensible an unsurprising defaults</li>
<li>Write your own backend or formatter, or use one of those provided</li>
<li>Flexible memory pool policies to control allocation in critical code</li>
<li>Optional journald sink for modern logging as well as a traditional file-based sink</li>
<li>Slog uses a custom <code>ostream</code> that writes directly to a preallocated buffer</li>
<li>Log records are never copied, just moved</li>
<li>Slog's mutex-guarded sections are very short &ndash; about four instructions maximum</li>
</ul>
<p>In fact, Slog began life as a lock-free project, but transitioned to mutexes when testing showed that the lock-free design no significant worst-case performance boost. <br  />
</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Quickstart</h1>
<p>Using slog is as simple as </p><div class="fragment"><div class="line"><span class="comment">/*** other_stuff.hpp ***/</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;slog.hpp&quot;</span> <span class="comment">// All that&#39;s needed where logging is happening</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> do_other_stuff()</div>
<div class="line">{</div>
<div class="line">    Slog(DBUG) &lt;&lt; <span class="stringliteral">&quot;You can see this&quot;</span>;</div>
<div class="line">    Slog(INFO, <span class="stringliteral">&quot;net&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;But not this&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> In the main.cpp, we can put some additional setup code </p><div class="fragment"><div class="line"><span class="comment">/*** main.cpp ***/</span></div>
<div class="line"><span class="preprocessor">#include &quot;LogSetup.hpp&quot;</span> <span class="comment">// Required for advanced setup</span></div>
<div class="line"><span class="preprocessor">#include &quot;other_stuff.hpp&quot;</span> <span class="comment">// Your logic here...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classslog_1_1LogConfig.html">slog::LogConfig</a> config;</div>
<div class="line">    config.<a class="code" href="classslog_1_1LogConfig.html#a8cafc838a4c0a4d28aa68c61bc76b437">set_default_threshold</a>(slog::DBUG);      <span class="comment">// Log everything DBUG or higher by default</span></div>
<div class="line">    config.<a class="code" href="classslog_1_1LogConfig.html#a79639436a5f95c63422194d6d64af189">add_tag</a>(<span class="stringliteral">&quot;net&quot;</span>, slog::NOTE);             <span class="comment">// Only log net-tagged messages at NOTE level</span></div>
<div class="line">    <span class="keyword">auto</span> sink = std::make_shared&lt;slog::FileSink&gt;();</div>
<div class="line">    sink-&gt;set_file(<span class="stringliteral">&quot;/tmp&quot;</span>, <span class="stringliteral">&quot;example&quot;</span>, <span class="stringliteral">&quot;slog&quot;</span>);     <span class="comment">// Name files &quot;/tmp/example_DATE_SEQUENCE.slog&quot;</span></div>
<div class="line">    sink-&gt;set_echo(<span class="keyword">false</span>);                         <span class="comment">// Don&#39;t echo to the console (default true)</span></div>
<div class="line">    sink-&gt;set_max_file_size(2 &gt;&gt; 30);              <span class="comment">// Roll over big files (default no limit)</span></div>
<div class="line">    config.<a class="code" href="classslog_1_1LogConfig.html#a76fe41a484dfc3e46ed36e72582d38be">set_sink</a>(sink);</div>
<div class="line">    slog::start_logger(config);</div>
<div class="line">    </div>
<div class="line">    do_other_stuff();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassslog_1_1LogConfig_html"><div class="ttname"><a href="classslog_1_1LogConfig.html">slog::LogConfig</a></div><div class="ttdef"><b>Definition:</b> LogSetup.hpp:81</div></div>
<div class="ttc" id="aclassslog_1_1LogConfig_html_a76fe41a484dfc3e46ed36e72582d38be"><div class="ttname"><a href="classslog_1_1LogConfig.html#a76fe41a484dfc3e46ed36e72582d38be">slog::LogConfig::set_sink</a></div><div class="ttdeci">void set_sink(std::shared_ptr&lt; LogSink &gt; sink_)</div><div class="ttdoc">Set the sink The sink saves log records. There are three sinks included: FileSink,...</div><div class="ttdef"><b>Definition:</b> LogSetup.hpp:101</div></div>
<div class="ttc" id="aclassslog_1_1LogConfig_html_a79639436a5f95c63422194d6d64af189"><div class="ttname"><a href="classslog_1_1LogConfig.html#a79639436a5f95c63422194d6d64af189">slog::LogConfig::add_tag</a></div><div class="ttdeci">void add_tag(const char *tag, int thr)</div><div class="ttdoc">Add a custom threshold for a tag.</div><div class="ttdef"><b>Definition:</b> LogSetup.hpp:94</div></div>
<div class="ttc" id="aclassslog_1_1LogConfig_html_a8cafc838a4c0a4d28aa68c61bc76b437"><div class="ttname"><a href="classslog_1_1LogConfig.html#a8cafc838a4c0a4d28aa68c61bc76b437">slog::LogConfig::set_default_threshold</a></div><div class="ttdeci">void set_default_threshold(int thr)</div><div class="ttdoc">Set the default threshold at which to accept records.</div><div class="ttdef"><b>Definition:</b> LogSetup.hpp:86</div></div>
</div><!-- fragment --><p> The <code>LogConfig</code> object contains the configuration for the logger. See the example project in <code>example</code> for a basic setup.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Design</h1>
<p>Slog has three design goals:</p>
<ol type="1">
<li>Do as little work on the business thread as possible</li>
<li>Minimize the include size for <code><a class="el" href="slog_8hpp_source.html">slog.hpp</a></code> and</li>
<li>Provide clear failure modes.</li>
</ol>
<p>For (1), Slog is asynchronous (see below). It also uses a special preallocated pool of log records to avoid allocating memory during log capture. It aggressively checks to see if a message will be logged at all, avoiding formatting the log string if the result would be ignored. This all means Slog stays out of the way of your program as much as possible.</p>
<p>Likewise for (2), Slog only includes <code>&lt;iostream&gt;</code> (and then only when streams are enabled). It doesn't use any templates in the logging API, keeping the compile-time cost of including <code><a class="el" href="slog_8hpp_source.html">slog.hpp</a></code> as small as possible. Goal (2) also precludes a header-only design, but building Slog as part of your project is very easy.</p>
<p>Failure modes (3) are important for critical applications. Memory and time resources are finite, so careful programs should have plans for cases where these run short. Slog provides three policies to control logging behavior when resources are tight:</p>
<ol type="1">
<li>Allocate: If the log record pool becomes exhausted, Slog will attempt to allocate more memory. This will slow down business code, but for general use, it ensures that the logger will function provided there's free memory. This is the default.</li>
<li>Block: If the pool is empty, block the business thread until records become available. The maximum time to block is configurable. If it is exhausted, the log record is ignored. This mode ensures that the memory used by the logger is bounded, and places a bound on the time per log message. With appropriate tuning, this policy can meet needs for real time systems.</li>
<li>Discard: If the pool is empty, discard the log record. This is the most extreme, never allocating or blocking. This choice is intended for real time applications where delay of the business logic could result in loss of life or grievous harm.</li>
</ol>
<h1><a class="anchor" id="autotoc_md3"></a>
Asynchronous Logging</h1>
<p>Slog is an <em>asynchronous</em> logger, meaning log records are written to sinks (files, sockets, etc.) on dedicated worker threads. "Logging" on a business thread captures the message to an internal buffer. This is then pushed into a thread-safe queue where a worker thread pops the message and performs the (blocking) IO call. This design minimizes blocking calls that are made on the business thread. The risk with asynchronous logging is that the program may terminate before this queue is written to disk. Slog ties into the signal system to ensure that the queue is processed before at exit in most cases. These cases include normal end of program (<code>return</code> from main) and the signals SIGINT, SIGABRT, and SIGQUIT. Thus Slog will drain its queue on all trappable signals (ctrl-C &ndash; SIG_INT &ndash; included), as well as when <code>abort()</code> is called. Note that calling <code>exit()</code> from <code>stdlib.h</code> is not one of these cases &ndash; this exits the program via a means that can evade the destructor of Slog's singleton. If you are slogging in a context where you need to call exit (i.e. you have forked), you must call <code>slog::stop_logger()</code> first to ensure a proper shutdown.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
API</h1>
<p>Slog's API is split into two parts: a very lightweight general include for code that needs to write logs (<code><a class="el" href="slog_8hpp_source.html">slog.hpp</a></code>), and a larger setup header that is used to configure the logger (<code><a class="el" href="LogSetup_8hpp_source.html">LogSetup.hpp</a></code>).</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Slog Concepts</h2>
<h3><a class="anchor" id="autotoc_md6"></a>
Severity</h3>
<p>Each message in Slog has an attached severity integer. These match the traditional syslog levels of DBUG, INFO, NOTE, WARN, ERRR, CRIT, ALRT, and EMER. You may add your own levels by using integers between the severity levels you want. For instance, to add a COOL level, we could set </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> COOL = (slog::NOTE + slog::WARN)/2;</div>
</div><!-- fragment --><p> Note that higher numbers are treated as less severe. In addition, negative severity is considered "FATL" by Slog, triggering the draining of all log queues and a call to <code>abort()</code> ending the program.</p>
<p>Slog filters messages based on a severity threshold per channel and per tag (see below). For example, if the threshold is set to NOTE, the code </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a = 0;</div>
<div class="line">Slog(INFO) &lt;&lt; <span class="stringliteral">&quot;Hello, I am incrementing a: &quot;</span> &lt;&lt; a++;</div>
</div><!-- fragment --><p> will not log. Moreover, the line right of <code>Slog()</code> will not be executed. (In the example, the value of <code>a</code> will be zero at the end.) Thresholds are set up in <code>LogConfig</code> before logging begins and cannot be changed while logging is happening. You can check if a message would be logged by calling <code>slog::will_log(severity, tag, channel)</code>.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Tags</h3>
<p>Each message may have an optional tag associated. These are size-limited strings (the default limit is 16 characters) that can have custom log thresholds. Tags that don't have defined thresholds use the default. For instance, keeping the same default threshold of NOTE as before, </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a = 0;</div>
<div class="line">Slog(INFO, <span class="stringliteral">&quot;noisy&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;Increment a: &quot;</span> &lt;&lt; a++;</div>
<div class="line">Slog(INFO) &lt;&lt; <span class="stringliteral">&quot;Increment a: &quot;</span>&lt;&lt; a++;</div>
</div><!-- fragment --><p> would log at most once, if we set the threshold for tag "noisy" to INFO or lower.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Channels</h3>
<p>Slog can be configured to have multiple <em>channels</em>. A channel corresponds to an independent back-end. <br  />
 Each channel has its own worker thread, its own sink, and its own set of severity thresholds. You can use this to separate events from data, for instance. Note that a particular message can be sent to only one channel. Channels may have independent memory pools with different policies and sizes or they can share pools with other channels. Slog represents a channel by an integer, with the default channel being channel 0.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
General Use</h2>
<p>Slog provides a set of function-like macros in <code><a class="el" href="slog_8hpp_source.html">slog.hpp</a></code> for logging. In general, this is the only include you'll need in locations where you log. The macros are</p>
<ul>
<li><code>Slog(SEVERITY) &lt;&lt; "My message"</code> : Log "My message" at level SEVERITY to the default channel with no tag. This provides a <code>std::ostream</code> stream to log to.</li>
<li><code>Slog(SEVERITY, "tag") &lt;&lt; "My message"</code> : Log "My message" at level SEVERITY to the default channel with tag "tag".</li>
<li><code>Slog(SEVERITY, "tag", 2) &lt;&lt; "My message"</code> : Log "My message" at level SEVERITY to channel 2 with tag "tag".</li>
<li><code>Flog(SEVERITY, "A good number is %d", 42)</code> : Log "A good number is 42" to the default channel with no tag. This uses printf-style formatting.</li>
<li><code>Flogt(SEVERITY, "tag", "A good number is %d", 42)</code> : Log "A good number is 42" to the default channel with tag "tag". This uses printf-style formatting.</li>
<li><code>Flogtc(SEVERITY, "tag", 2, "A good number is %d", 42)</code> : Log "A good number is 42" to channel 2 with tag "tag". This uses printf-style formatting.</li>
</ul>
<p>All of these macros aggressively check if the message will be logged given the current severity threshold for the tag and channel. If the message won't be logged, the code afterwards <em>will not be executed</em>. That is, no strings are formatted, no work is done. Moreover, depending on setup, if the message pool is empty, these macros may (a) allocate, causing a delay (b) block for a configurable amount of time waiting for a message to become available or (c) simply discard the log message.</p>
<p>Slog uses a custom <code>std::ostream</code> class that avoids the inefficiencies of <code>std::stringstream</code>. For the Flog family of macros, formatting is performed with <code>vsnprintf</code>.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Setup</h2>
<p>For your main, <code><a class="el" href="LogSetup_8hpp_source.html">LogSetup.hpp</a></code> provides the API for configuring your log. There are three start calls:</p>
<ol type="1">
<li><code>void start_logger(int severity_threshold)</code> : Start the logger with the default file sink back-end and the simple severity threshold given for all tags. This only sets up the default channel.</li>
<li><code>void start_logger(LogConfig const&amp; config)</code> : Start the logger using the given configuration for the default channel. See below for the <code>LogConfig</code> object.</li>
<li><code>void start_logger(std::vector&lt;LogConfig&gt; const&amp; configs)</code>: Start the logger using the given set of configs for each channel. The default channel <code>0</code> uses the front config.</li>
</ol>
<p>The LogConfig object provides a small API for configuring the logger behavior:</p>
<ul>
<li><code>LogConfig::set_default_threshold(int thr)</code> : Sets the default severity threshold for all (or no) tags.</li>
<li><code>LogConfig::add_tag(const char* tag, int thr)</code> : Sets the threshold <code>thr</code> for tag <code>tag</code>.</li>
<li><code>LogConfig::set_sink(std::unique_ptr&lt;LogSink&gt; sink)</code> : Takes the log sink instance given to use for the back end.</li>
<li><code>LogConfig::set_sink(LogSink* sink)</code> : Takes the log sink instance given to use for the back end. Slog takes ownership of the pointer and will perform cleanup when required.</li>
</ul>
<p>In addition, you may call <code>stop_logger()</code> to cease logging, but this isn't required before program termination.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Log Sinks</h2>
<p>Slog comes with three built-in sinks for recording messages, <code>ConsoleSink</code>, <code>FileSink</code> and <code>JournaldSink</code>. If none of these work for you, you may also make your own sinks by implementing the very simple API.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
ConsoleSink</h3>
<p><code>ConsoleSink</code> writes messages to <code>stdout</code>. It has only one feature:</p><ul>
<li><code>set_formatter(Formatter format)</code>: Adjust the format of log messages. See below about Formatters.</li>
</ul>
<h3><a class="anchor" id="autotoc_md13"></a>
FileSink</h3>
<p><code>FileSink</code> writes log messages to a file via the <code>fprintf()</code> API. It can also optionally echo those messages to <code>stdout</code>. It has a handful of useful features:</p>
<ol type="1">
<li><code>set_echo(bool)</code> : Echo (or don't) messages to the console. Defaults to true.</li>
<li><code>set_max_file_size(int)</code> : Set the maximum file size before rolling over to a new file. Defaults to unlimited.</li>
<li><code>set_file(char const* location, char const* name, char const* end="log")</code> : Sets the naming pattern for files. <code>location</code> is the directory to write files to. It defaults to <code>.</code>. <code>name</code> is the "stem" of the file name. It defaults to the program name. <code>end</code> is the filename extension. It defaults to <code>log</code>. The overall filename takes the form <code>[location]/[name]_[ISO Date]_[sequence].[end]</code>, where <code>ISO Date</code> is the ISO 8601 timestamp when the program started and <code>sequence</code> is a three digit counter that increases as rollover happens.</li>
<li><code>set_formatter(Formatter format)</code>: Adjust the format of log messages. See below.</li>
</ol>
<p>Formatter is an alias for <code>std::function&lt;int (FILE* sink, LogRecord const&amp; rec)&gt;</code>. This takes the file to write to and the message to write and records it, returning the number of bytes written. The default formatter in <code>LogSink.cpp</code> is a good example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> default_format(FILE* sink, LogRecord <span class="keyword">const</span>&amp;) {    </div>
<div class="line">    <span class="keywordtype">char</span> severity_str[16];</div>
<div class="line">    <span class="keywordtype">char</span> time_str[32];</div>
<div class="line">    format_severity(severity_str, rec.meta.severity);</div>
<div class="line">    format_time(time_str, rec.meta.time, 3);    </div>
<div class="line">    <span class="keywordtype">int</span> count = fprintf(sink, <span class="stringliteral">&quot;[%s %s %s] %s&quot;</span>, severity_str, rec.meta.tag, time_str, rec.message);</div>
<div class="line">    <span class="comment">// Note handling of oversized records</span></div>
<div class="line">    <span class="keywordflow">for</span> (LogRecord <span class="keyword">const</span>* more = rec.more; more != <span class="keyword">nullptr</span>; more = more-&gt;more) {</div>
<div class="line">        count += fprintf(sink, <span class="stringliteral">&quot;%s&quot;</span>, more-&gt;message);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> count;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that <code>rec.more</code> is a pointer to more message data if the message exceeds the size available in a single record. The metadata for the <code>more</code> record is not meaningful.</p>
<p>The <code>LogRecord</code> meta contains useful metadata about the record: </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> tag[TAG_SIZE];      </div>
<div class="line"><span class="keywordtype">char</span> <span class="keyword">const</span>* filename;    </div>
<div class="line"><span class="keywordtype">char</span> <span class="keyword">const</span>* <span class="keyword">function</span>;    </div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> time;      </div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> thread_id; </div>
<div class="line"><span class="keywordtype">int</span> line;                </div>
<div class="line"><span class="keywordtype">int</span> severity;            <span class="comment">//! Message importance. Lower numbers are more important    </span></div>
</div><!-- fragment --><p> As you can see, the default formatter doesn't include all of this information, but you can easily customize it.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
JournaldSink</h3>
<p>The Journald sink uses the structured logging features of Jornald to record the metadata. These are logged as </p><div class="fragment"><div class="line">sd_journal_send(</div>
<div class="line">    <span class="stringliteral">&quot;CODE_FUNC=%s&quot;</span>, rec.meta.function,</div>
<div class="line">    <span class="stringliteral">&quot;CODE_FILE=%s&quot;</span>, rec.meta.filename,</div>
<div class="line">    <span class="stringliteral">&quot;CODE_LINE=%d&quot;</span>, rec.meta.line,</div>
<div class="line">    <span class="stringliteral">&quot;THREAD=%ld&quot;</span>,   rec.meta.thread_id,</div>
<div class="line">    <span class="stringliteral">&quot;TIMESTAMP=%s&quot;</span>, isoTime,</div>
<div class="line">    <span class="stringliteral">&quot;PRIORITY=%d&quot;</span>,  rec.meta.severity/100,</div>
<div class="line">    <span class="stringliteral">&quot;MESSAGE=%s&quot;</span>,   rec.message,</div>
<div class="line">    NULL); </div>
</div><!-- fragment --><p> allowing you to use the Jornald features to filter the logs. For a great introduction to this, see <a href="http://0pointer.de/blog/projects/journalctl.html">http://0pointer.de/blog/projects/journalctl.html</a>.</p>
<p>The sink also provides optional echoing to the console. The echoed logs use the same <code>Formatter</code> function object as <code>FileSink</code>.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Tweaking the Format</h2>
<p>The built-in sinks all use the <code>Formatter</code> functor defined in <code><a class="el" href="LogSink_8hpp_source.html">LogSink.hpp</a></code> to format messages: </p><div class="fragment"><div class="line"><span class="keyword">using</span> Formatter = std::function&lt;int (FILE* sink, LogRecord <span class="keyword">const</span>&amp; node)&gt;;</div>
</div><!-- fragment --><p> This should return the number of bytes written to the <code>sink</code>. You can use a lambda in the setup to customize the format to your liking. Functions in <code><a class="el" href="LogSink_8hpp_source.html">LogSink.hpp</a></code> provide date, severity, and code location format helpers that should make creating your own formatter easy.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Writing Your Own Sink</h2>
<p>Log sinks derive from this abstract class defined in <code><a class="el" href="LogSink_8hpp_source.html">LogSink.hpp</a></code>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>LogSink</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~LogSink() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> record(LogRecord <span class="keyword">const</span>&amp; record) = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p> As you can see, you can do what you like in <code>record</code>. The <code>Formatter</code> functor provides a convenient way to allow users to customize the format, but you don't have to use it.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Locale Setting</h2>
<p>Slog uses a thread-local stream object that is initialized in an order you can't control (the old static initialization fiasco of C++ lore). As such, if you change the global locale after starting the logger, the streams will not pick up on this by default. You can force Slog to update the stream locale via <code>void set_locale(std::locale locale)</code> or <code>void set_locale_to_global()</code>.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Building Slog</h1>
<p>Slog is written in C++11 and has no required dependencies. You'll probably be happiest building it as part of a CMake super-build. To do so, add this project as a subdirectory of your code and put </p><div class="fragment"><div class="line">add_subdirectory(slog)</div>
</div><!-- fragment --><p> in your <code>CMakeLists.txt</code> file. This will give you the target <code>slog</code> that you can depend on. Slog is a very small library and won't significantly impact compile times.</p>
<p>Slog has an optional dependency on libsystemd for the journal sink. To use this, you'll need to install the systemd development package for your OS. In Debian or Ubuntu, you can do this via </p><div class="fragment"><div class="line">apt install libsystemd-dev</div>
</div><!-- fragment --><p> Note that this doesn't add any <em>runtime</em> dependencies to your application, you just need the headers for building.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
LogConfig</h1>
<p>The <code>LogConfig</code> object is declared in <code><a class="el" href="LogSetup_8hpp_source.html">LogSetup.hpp</a></code> and offers control over the logging process. You supply one LogConfig per channel you want to log (a <code>std::vector&lt;LogConfig&gt;</code>). If you just need one channel, you can pass a bare <code>LogConfig</code>.</p>
<p>The setup methods are:</p>
<ul>
<li><code>set_default_threshold(int thr)</code>: Set the default severity threshold for logging. Default is <code>slog::INFO</code></li>
<li><code>add_tag(const char* tag, int thr)</code>: Set a special threshold for the given tag</li>
<li><code>set_sink(std::shared_ptr&lt;LogSink&gt; sink_)</code>: Set the sink you'd like to use (FileSink, JournaldSink, etc.). The default sink is the FileSink.</li>
<li><code>set_pool(std::shared_ptr&lt;LogRecordPool&gt; pool_)</code>: Set the record pool. The default pool is an allocating record pool that allocates in 1 MB chunks with 1 kB records.</li>
</ul>
<h2><a class="anchor" id="autotoc_md20"></a>
LogRecordPool</h2>
<p>The <code>LogRecordPool</code> constructor sets up the pool policies: </p><div class="fragment"><div class="line">LogRecordPool(LogRecordPoolPolicy i_policy, <span class="keywordtype">long</span> i_pool_alloc_size, <span class="keywordtype">long</span> i_message_size,</div>
<div class="line">        <span class="keywordtype">long</span> i_max_blocking_time_ms = 50);</div>
</div><!-- fragment --><p> The available policies are</p><ul>
<li>ALLOCATE: <code>malloc</code> more memory when the pool is empty</li>
<li>BLOCK: block the business thread in the Slog() call until a record is available</li>
<li>DISCARD: Discard the message in the Slog() call if no record is available</li>
</ul>
<p>The other parameters are</p><ul>
<li><code>i_pool_alloc_size</code> controls the size of each pool allocation. The default pool uses a 1 MB allocation.</li>
<li><code>i_message_size</code> controls the size of a single message. Longer messages are formed using the "jumbo" pointer &ndash; concatenating multiple records from the pool. Choosing this to be a bit longer than your typical message can give you good performance. The default pool uses 1 kB messages, roughly ten terminal lines of text.</li>
<li><code>i_max_blocking_time_ms</code> sets the maximum blocking time in milliseconds when <code>i_policy</code> is <code>BLOCK</code>. It has no impact for ALLOCATE or DISCARD policies.</li>
</ul>
<p>The record pool is fully thread-safe, so sharing one pool <code>shared_ptr</code> between multiple channels works fine.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Compile-time Configuration</h1>
<p>Slog has two compile-time cmake configuration options:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Default   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>SLOG_ALWAYS_LOG</code>   </td><td class="markdownTableBodyNone">OFF   </td><td class="markdownTableBodyNone">When the logger is stopped, dump records to the console    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>SLOG_STREAM</code>   </td><td class="markdownTableBodyNone">ON   </td><td class="markdownTableBodyNone">Turn this off to avoid including &lt;iostream&gt; and Slog() macros   </td></tr>
</table>
<p>In addition, building with <code>-DSLOG_LOGGING_ENABLED=0</code> will suppress all logging in this translation unit. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
